
/** 
 *  SUM_ARRAY HUFF EXERCISE
 *
 * In this puzzle, the task is to simulate an array in Huff using the "exact" storage pattern as solidity. Expected functions can; 
 *      - Push numbers onto a array, 
 *      - Pop the last index from the array,
 *      - View what's stored at an index, 
 *      - Gets the length of the array, 
 *      - Write to an index if it is valid.
 *
 *      - Writes and reads outside of length revert. 
 *      - Popping off a zero length array reverts.
 *
 *  NOTICE: The contract should revert when an unrecognized function is called
 */

 #define function pushh(uint256 num) payable returns()
 #define function popp() payable returns()
 #define function read(uint256 index) payable returns(uint256)
 #define function length() payable returns(uint256)
 #define function write(uint256 index, uint256 num) payable returns()

 #define error OutOfBounds()
 #define error ZeroArray()

 #define macro MAIN() = takes(0) returns(0) {
    // Get the function selector
    0x00 calldataload 0xe0 shr
    dup1 __FUNC_SIG(pushh) eq pushh jumpi
    dup1 __FUNC_SIG(popp) eq popp jumpi
    dup1 __FUNC_SIG(read) eq read jumpi
    dup1 __FUNC_SIG(length) eq length jumpi
    __FUNC_SIG(write) eq write jumpi
    

    revertJump:
        0x00 0x00 revert
    
    endJump:
        0x01 0x00 mstore
        0x20 0x00 return
    
    pushh:
        0x04 calldataload           // get new element  [element]
        0x00 sload                  // get nArgs in array   [element, nArgs]   
        0x01 add                    // increment nArgs in array [element, nArgs+1]
        dup1                        // duplicate result     [element, nArgs+1, nArgs+1]
        0x00 sstore                 // store nArgs          [element, nArgs+1]
        sstore                      // store new element    []
        0x00 0x00 return

    popp:
        0x00 sload                  // get nArgs in array   [nArgs]
        dup1 iszero revertPop jumpi // check if nArgs > 0
        0x00                        // load 0               [nArgs, 0]
        dup2                        // get nArgs in array   [nArgs, 0, nArgs]
        sstore                      // [nArgs]
        0x01                        // [nArgs, 1]
        swap1                       // [1, nArgs]
        sub                         // [res]
        0x00 sstore                 // []
        0x00 0x00 return
    
    revertPop:
        __ERROR(ZeroArray) 0x00 mstore
        0x04 0x00 revert


    read:

        0x00 sload                  // get nArgs  [nArgs]
        0x04 calldataload           // get idx element  [nArgs, idx]
        dup1 swap2 gt completeRead jumpi       // [nArgs, idx, idx] -> [idx, idx, nArgs] -> [idx, 1/0] -> [idx]
        __ERROR(OutOfBounds) 0x00 mstore
        0x04 0x00 revert

    
    completeRead:
        0x01 add                    // get index in storage [idx]
        sload                       // get value at index on storage [res]
        0x00 mstore                 // place the result in memory
        0x20 0x00 return            // return the result

    length:
        0x00 sload                  // get nArgs in array   [nArgs]
        0x00 mstore                 // place the nArgs in memory
        0x20 0x00 return            // return the nArgs

    write:
        0x00 sload                  // get nArgs  [nArgs]
        0x04 calldataload           // get idx element  [nArgs, idx]
        dup1 swap2 gt completeWrite jumpi       // [nArgs, idx, idx] -> [idx, idx, nArgs] -> [idx, 1/0] -> [idx]
        __ERROR(OutOfBounds) 0x00 mstore
        0x04 0x00 revert
    
    completeWrite:
        0x01 add                    // update idx element at storage  [idx]
        0x24 calldataload           // get num element  [idx, num]
        swap1 sstore
 }